# 复合类型
## 切片
[开始索引..终止索引]
```rust
let s = String::from("hello");
let len = s.len();
let slice = &s[0..len];
```
字符串字面量是切片
```rust
let s = "Hello, world!";
// 等价为
let s: &str = "Hello, world!"; // 不可变引用
```

## 字符串
> Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)，这样有助于大幅降低字符串所占用的内存空间。

当 Rust 用户提到字符串时，往往指的就是 String 类型和 &str 字符串切片类型，这两个类型都是 UTF-8 编码。

### String 与 &str 的转换
* &str 类型生成 String 
```rust
String::from("hello,world")
"hello,world".to_string()
```
*  String 类型转为 &str
```rust
fn main() {
    let s = String::from("hello,world!");
    say_hello(&s);
    say_hello(&s[..]);
    say_hello(s.as_str());
}

fn say_hello(s: &str) {
    println!("{}",s);
}
```
### 字符串索引
> Rust不可利用索引的方式访问字符串

```rust
// 会报错
let s1 = String::from("hello");
let h = s1[0];
```
原因：
* `hello`长度是5个字节，因为`hello`中的每个字母在 UTF-8 编码中仅占用 1 个字节；但如果是中文`你好`，实际6个字节的长度，因为大部分常用汉字在 UTF-8 中的长度是 3 个字节，此时利用索引`s1[0]`取不到`你`这个字符。
* 因为索引操作，我们总是期望它的性能表现是 O(1)，然而对于 String 类型来说，无法保证这一点，因为 Rust 可能需要从 0 开始去遍历字符串来定位合法的字符。所以不允许索引字符串

### 操作字符串
#### 追加
`push()` 方法追加字符 char，也可以使用 `push_str()` 方法追加字符串字面量。这两个方法都是在原有的字符串上追加，并不会返回新的字符串。由于字符串追加操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由 mut 关键字修饰。

#### 插入
`insert()` 方法插入单个字符 char，也可以使用 `insert_str()` 方法插入字符串字面量，与 push() 方法不同，这俩方法需要传入两个参数，第一个参数是字符（串）插入位置的索引，第二个参数是要插入的字符（串），索引从 0 开始计数，如果越界则会发生错误。由于字符串插入操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由 mut 关键字修饰。

#### 替换
* replace：
该方法可适用于 String 和 &str 类型。`replace()` 方法接收两个参数，第一个参数是要被替换的字符串，第二个参数是新的字符串。该方法会替换所有匹配到的字符串。该方法是返回一个新的字符串，而不是操作原来的字符串。
* replacen：
该方法可适用于 String 和 &str 类型。`replacen()` 方法接收三个参数，前两个参数与 replace() 方法一样，第三个参数则表示替换的个数。该方法是返回一个新的字符串，而不是操作原来的字符串。
* replace_range：
该方法仅适用于 String 类型。`replace_rang` 接收两个参数，第一个参数是要替换字符串的范围（Range），第二个参数是新的字符串。该方法是直接操作原来的字符串，不会返回新的字符串。该方法需要使用 mut 关键字修饰。
```rust
fn main() {
    let mut string_replace_range = String::from("I like rust!");
    string_replace_range.replace_range(7..8, "R");
    dbg!(string_replace_range);
}
```
#### 删除
* pop：删除并返回字符串的最后一个字符，该方法是直接操作原来的字符串。但是存在返回值，其返回值是一个 Option 类型，如果字符串为空，则返回 None。
* remove：删除并返回字符串中指定位置的字符，接收一个参数，表示该字符起始索引位置。remove() 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。
* truncate：删除字符串中从指定位置开始到结尾的全部字符；该方法是直接操作原来的字符串。无返回值。该方法 truncate() 方法是按照字节来处理字符串的，如果参数所给的位置不是合法的字符边界，则会发生错误。
* clear：清空字符串；该方法是直接操作原来的字符串。调用后，删除字符串中的所有字符，相当于 `truncate()` 方法参数为 0 的时候。

#### 连接
* 使用 + 或者 += 连接字符串：要求右边的参数必须为字符串的切片引用（Slice）类型。其实当调用 + 的操作符时，相当于调用了 std::string 标准库中的 add() 方法，这里 add() 方法的第二个参数是一个引用的类型。因此我们在使用 +， 必须传递切片引用类型。不能直接传递 String 类型。+ 是返回一个新的字符串，所以变量声明可以不需要 mut 关键字修饰。
```rust
fn add(self, s: &str) -> String // 变量通过调用 add() 方法后，self参数所有权被转移到 add() 方法里面， add() 方法调用后就被释放了，同时 self参数 也被释放了。再使用 self参数 就会发生错误。
```
* 使用 format! 连接字符串：format! 这种方式适用于 String 和 &str 。format! 的用法与 print! 的用法类似。
```rust
fn main() {
    let s1 = "hello";
    let s2 = String::from("rust");
    let s = format!("{} {}!", s1, s2);
    println!("{}", s);
}
```

#### 字符串转义
通过转义的方式 `\` 输出 ASCII 和 Unicode 字符。

#### 操作 UTF-8 字符串
##### 字符

如果你想要以 Unicode 字符的方式遍历字符串，最好的办法是使用 chars 方法，例如：
```rust
for c in "中国人".chars() {
    println!("{}", c);
}
```
##### 字节
```rust
for b in "中国人".bytes() {
    println!("{}", b);
}
```

### 字符串剖析


为什么 `String` 可变，而字符串字面值 `str` 却不可以：字符串字面值在编译时就知道其内容，被直接硬编码进可执行文件中，字符串字面值快速且高效； `String` 类型，为了支持一个可变、可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容，首先向操作系统请求内存来存放 String 对象，在使用完成后，将内存释放，归还给操作系统。

与其它系统编程语言的 `free` 函数相同，Rust 也提供了一个释放内存的函数： `drop`，但是不同的是，其它语言要手动调用 `free` 来释放每一个变量占用的内存，而 Rust 则在变量离开作用域时，自动调用 `drop` 函数: 上面代码中，Rust 在结尾的 `}` 处自动调用 `drop`。