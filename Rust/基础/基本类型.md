# 基础
## 变量
### 变量绑定
不用赋值而用绑定，因为任何对象都是有它的主人的，绑定就是把这个对象绑定给一个变量，让这个变量成为它的主人。`所有权`概念
### 变量可变性
```rust
let a = "hello world" // 不可变
let mut a = "hello world" //可变（mut是mutable的缩写）
```
* 不可变原因：使代码更安全，将本身无需改变的变量声明为不可变在运行期会避免一些多余的 runtime 检查使得性能更好。
* 可变原因：让程序设计更灵活，无需重新创建新的变量使得性能提升
### 变量和常量差异
* 常量不允许使用 mut。且自始至终不可变，因为常量在编译完成后，已经确定它的值。
* 常量使用 const 关键字而不是 let 关键字来声明，并且值的类型必须标注。
### 变量遮蔽
```rust
let x = 5;
// 在main函数的作用域内对之前的x进行遮蔽
let x = x + 1;
```
遮蔽生成了完全不同的新变量，涉及到一次内存对象再分配。被遮蔽后无法再次访问之前的同名变量。mut 声明的变量，可以修改同一个内存地址上的值，并不会发生内存对象的再分配，性能要更好

## 基本类型
 * 数值类型: 有符号整数 (i8, i16, i32, i64, isize)、 无符号整数 (u8, u16, u32, u64, usize) 、浮点数 (f32, f64)、以及有理数、复数
* 字符串：字符串字面量和字符串切片 &str
* 布尔类型： true和false
* 字符类型: 表示单个 Unicode 字符，存储为 4 个字节
* 单元类型: 即 () ，其唯一的值也是 ()

> 部分场景无需显示声明变量类型，它可以根据变量的值和上下文中的使用方式来自动推导出变量的类型；也有一部分编译器无法推导出变量类型，就需要手动声明变量类型
### 数值类型
#### 整数
> 有符号数字范围：数字范围是 -(2n - 1) ~ 2n - 1 - 1; 无符号数字范围： 0 ~ 2n - 1


| 长度       | 有符号类型 | 无符号类型 |
| ---------- | ---------- | ---------- |
| 8 位       | `i8`       | `u8`       |
| 16 位      | `i16`      | `u16`      |
| 32 位      | `i32`      | `u32`      |
| 64 位      | `i64`      | `u64`      |
| 128 位     | `i128`     | `u128`     |
| 视架构而定 | `isize`    | `usize`    |

#### 浮点数
> 浮点数类型是基于二进制实现的, 通常计算的数字是基于十进制的。0.1 在二进制上并不存在精确的表达形式。由于底层格式问题，它往往受限于定长的浮点数精度。避免在浮点数上测试相等性

f32 和 f64
#### 位运算

| 运算符  | 说明                                                   |
| ------- | ------------------------------------------------------ |
| & 位与  | 相同位置均为1时则为1，否则为0                          |
| \| 位或 | 相同位置只要有1时则为1，否则为0                        |
| ^ 异或  | 相同位置不相同则为1，相同则为0                         |
| ! 位非  | 把位中的0和1相互取反，即0置为1，1置为0                 |
| << 左移 | 所有位向左移动指定位数，右位补0                        |
| >> 右移 | 所有位向右移动指定位数，带符号移动（正数补0，负数补1） |

#### 序列
```rust
// 生成从 1 到 4 的连续数字，不包含 5
for i in 1..=5 {
    println!("{}",i);
}
```
#### as类型转换
> 可以对原始类型转换或指针和地址的转换
```rust
let a = 3.1 as i8;
```

#### 有理数和复数
并未包含在标准库中，需要呀引入数值库：[num](https://crates.io/crates/num)

### 字符串
Rust 的字符用 '' 来表示
### String类型
字符串字面值 `let s ="hello"`，s 是被硬编码进程序里的字符串值（类型为 &str ）。字符串字面值是很方便的，但是它并不适用于所有场景。原因有二：
* 字符串字面值是不可变的，因为被硬编码到程序代码中
* 并非所有字符串的值都能在编写代码时得知

动态字符串类型: String, 该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本。
```rust
let s = String::from("hello");
```
### 布尔
true 和 false，布尔值占用内存的大小为 1 个字节
### 单元类型
`fn main() `函数中`()`就是表示返回的单元类型。没有返回值的函数在 Rust 中是有单独的定义的：`发散函数( diverge function )`。可以用 `()` 作为 `map` 的值，表示我们不关注具体的值，只关注 key。 这种用法和 Go 语言的 `struct{}` 类似，可以作为一个值用来占位，但是完全不占用任何内存。

`::` 是一种调用操作符，这里表示调用 String 中的 from 方法，因为 String 存储在堆上是动态的，你可以这样修改它：
```rust
let mut s = String::from("hello");
s.push_str(", world!"); // push_str() 在字符串后追加字面值
println!("{}", s); // 将打印 `hello, world!`
```

### 语句和表达式
Rust 的函数体是由一系列语句组成，最后由一个表达式来返回值，例如：
```rust
fn add_with_extra(x: i32, y: i32) -> i32 {
    let x = x + 1; // 语句
    let y = y + 5; // 语句
    x + y // 表达式
}
```
语句：语句完成了一个具体的操作，没有返回值。
表达式：表达式会进行求值，然后返回一个值。**表达式不能以分号结尾**，否则就会从表达式变成语句。表达式如果不返回任何值，会隐式地返回一个 `()`

### 函数
* 函数名和变量名使用蛇形命名法，例如 `fn add_two() -> {}`
* 函数的位置可以随便放，Rust 不关心我们在哪里定义了函数，只要有定义即可
* 每个函数参数都需要标注类型
* 函数的返回值就是函数体最后一条***表达式***的返回值，也可以使用 return 提前返回

无返回值函数
* 无返回值函数会地返回一个单于类型 `()`

不返回值的发散函数
* 当用 `!` 作函数返回类型的时候，表示该函数永不返回
```rust
fn dead_end() -> ! {
  panic!("你已经到了穷途末路，崩溃吧！");
}
```
