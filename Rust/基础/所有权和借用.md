# 所有权和借用
## 所有权
开发语言内存管理的三种常见方式
* 垃圾回收机制(GC)，在程序运行时不断寻找不再使用的内存，典型代表：Java、Go
* 手动管理内存的分配和释放, 在程序中，通过函数调用的方式来申请和释放内存，典型代表：C++
* 通过所有权来管理内存，编译器在编译时会根据一系列规则进行检查

C++中指针容易发生的两类问题：
* 悬空指针（dangling pointer）：又叫野指针（wild pointer），是指非空的指针没能指向相应类型的有效对象，或者换句话说，不能解析到一个有效的值。这有可能是对指针做了错误的运算，或者目标内存被意外回收了。
* 内存泄漏（memory leak）：是指因为疏忽或者错误，没有释放已经不再使用的内存，造成内存的浪费。在 C/C++ 这类没有内存管理的语言里，常见的泄漏原因是在释放动态分配的内存之前，就失去了对这些内存的控制。

在GO语言中的解决方案：
* 逃逸分析：由编译器对变量进行逃逸分析，判断变量的作用域是否超出函数的作用域，以此决定将内存分配在栈上还是堆上，不需要人工指定。这就解决了第一个问题，函数内部声明的变量，其内存可以在函数返回后继续使用。
* 垃圾回收：由运行时（runtime）负责不再引用的内存的回收。回收算法一直在改进，这里不展开。这就解决了第二个问题，当内存不再使用的时候，只要不引用即可（指针置零，或者指向别的内存），不需要手动释放。

在Rust中的解决方案：
* 编译器会通过生命周期判断，有问题在编译时会抛出错误

### 栈与堆
#### 栈
> 后进先出

栈中的所有数据都必须占用已知且固定大小的内存空间，假设数据大小是未知的，那么在取出数据时，你将无法取到你想要的数据。
#### 堆
向堆上放入数据时，需要请求一定大小的内存空间。操作系统在堆的某处找到一块足够大的空位，把它标记为已使用，并返回一个表示该位置地址的指针, 该过程被称为在堆上分配内存。该指针会被推入栈中，因为指针的大小是已知且固定的，在后续使用过程中，你将通过栈中的指针，来获取数据在堆上的实际内存位置，进而访问该数据。

#### 性能差异
写入方面：入栈比在堆上分配内存要快，因为入栈时操作系统无需分配新的空间，只需要将新数据放入栈顶即可。相比之下，在堆上分配内存则需要更多的工作，这是因为操作系统必须首先找到一块足够存放数据的内存空间，接着做一些记录为下一次分配做准备。

读取方面：得益于 CPU 高速缓存，使得处理器可以减少对内存的访问，高速缓存和内存的访问速度差异在 10 倍以上！栈数据往往可以直接存储在 CPU 高速缓存中，而堆数据只能存储在内存中。访问堆上的数据比访问栈上的数据慢，因为必须先访问栈再通过栈上的指针来访问内存。

#### 所有权与堆栈
调用一个函数时，传递给函数的参数（包括可能指向堆上数据的指针和函数的局部变量）依次被压入栈中，当函数调用结束时，这些值将被从栈中按照相反的顺序依次移除。

堆上的数据缺乏组织，因此跟踪这些数据何时分配和释放是非常重要的，否则堆上的数据将产生内存泄漏 

### 所有权原则
* Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者
* 一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者
* 当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)

### 变量绑定背后的数据交互
#### 转移所有权
```rust
//将 5 绑定到变量 x；接着拷贝 x 的值赋给 y，最终 x 和 y 都等于 5
let x = 5;
let y = x;
```
这两个值都是通过自动拷贝的方式来赋值的，都被存在栈中，完全无需在堆上分配内存。 Rust 基本类型都是通过自动拷贝的方式来赋值

```rust
let s1 = String::from("hello");
let s2 = s1;
```
String 不是基本类型，而且是存储在堆上的，因此不能自动拷贝。 String 类型是一个复杂类型，由存储在栈中的堆指针、字符串长度、字符串容量共同组成，其中堆指针是最重要的，它指向了真实存储字符串内容的堆内存.

String拷贝两种做法：
* 深拷贝，对性能影响大
* 浅拷贝，违背了**一个值只允许有一个所有者**。造成问题是。当变量离开作用域后，Rust 会自动调用 `drop` 函数并清理变量的堆内存，会产生**二次释放（double free）**影响内存安全导致内存污染。

Rust解决方案：

当 s1 赋予 s2 后，Rust 认为 s1 不再有效，因此也无需在 s1 离开作用域后 drop 任何东西，这就是把所有权从 s1 转移给了 s2，s1 在被赋予 s2 后就马上失效了。因此这个操作被称为 **移动(move)**，而不是浅拷贝。

#### 深拷贝
Rust 永远也不会自动创建数据的 “深拷贝”。如果需要深拷贝手动声明。
```rust
let s1 = String::from("hello");
let s2 = s1.clone();
```
#### 浅拷贝
浅拷贝只发生在栈上，因此性能很高。
基本类型在编译时是已知大小的，会被存储在栈上，所以拷贝其实际的值是快速的。任何基本类型的组合可以 `Copy` ，不需要分配内存或某种形式资源的类型是可以 `Copy` 的。其中还包含【不可变引用 &T 】但是注意: 可变引用 &mut T 是不可以 `Copy`的

### 函数传值与返回
将值传递给函数，一样会发生 移动 或者 复制，就跟 let 语句一样
```rust
fn main() {
    let s = String::from("hello");  // s 进入作用域
    takes_ownership(s);             // s 的值移动到函数里 ...
                                    // ... 所以到这里不再有效
    let x = 5;                      // x 进入作用域
    makes_copy(x);                  // x 应该移动函数里，
                                    // 但 i32 是 Copy 的，所以在后面可继续使用 x

} // 这里, x 先移出了作用域，然后是 s。但因为 s 的值已被移走，所以不会有特殊操作
fn takes_ownership(some_string: String) { // some_string 进入作用域
    println!("{}", some_string);
} // 这里，some_string 移出作用域并调用 `drop` 方法。占用的内存被释放
fn makes_copy(some_integer: i32) { // some_integer 进入作用域
    println!("{}", some_integer);
} // 这里，some_integer 移出作用域。不会有特殊操作
```
同样的，函数返回值也有所有权。

所有权很强大，避免了内存的不安全性，但是也带来了一个新麻烦： 总是把一个值传来传去来使用它。可以通过**借用**来解决这个问题。

## 引用与借用
### 引用与解引用
```rust
fn main() {
    let x = 5;
    let y = &x; // 引用
    assert_eq!(5, x);
    assert_eq!(5, *y); // 解引用
}
```
### 不可变引用
```rust
// 无需再先通过函数参数传入所有权，然后再通过函数返回来传出所有权，使得代码更加简洁。
// 引用允许你使用值，但是不获取所有权，所以离开作用域后也不会被丢弃
// 但引用指向的值默认也是不可变的
fn main() {
    let s1 = String::from("hello");
    let len = calculate_length(&s1);
    println!("The length of '{}' is {}.", s1, len);
}
fn calculate_length(s: &String) -> usize {
    s.len()
}
```
### 可变引用
```rust
fn main() {
    let mut s = String::from("hello");
    change(&mut s);
}
fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
但同一作用域，可变引用同时只能存在一个：
```rust
// 此时会报错，第一个可变借用 r1 必须要持续到最后一次使用的位置
let mut s = String::from("hello");
let r1 = &mut s;
let r2 = &mut s;
println!("{}, {}", r1, r2);
```
这种限制的好处就是使 Rust 在编译期就避免数据竞争，数据竞争可由以下行为造成：
* 两个或更多的指针同时访问同一数据
* 至少有一个指针被用来写入数据
* 没有同步数据访问的机制

可变引用与不可变引用不能同时存在
```rust
// 此时会报错，第一个可变借用 r1 必须要持续到最后一次使用的位置
let mut s = String::from("hello");
let r1 = &s;
let r2 = &s;
let r3 = &mut s; // 出现问题
println!("{}, {}, and {}", r1, r2, r3);
```
这种限制的好处是：借用不可变引用的用户不会有人去修改，因此不用担心数据被污染。

> 注意，引用的作用域 s 从创建开始，一直持续到它最后一次使用的地方，这个跟变量的作用域有所不同，变量的作用域从创建持续到某一个花括号}

```rust
fn main() {
   let mut s = String::from("hello");
    let r1 = &s;
    let r2 = &s;
    println!("{} and {}", r1, r2);
    // 新编译器中，r1,r2作用域在这里结束
    let r3 = &mut s;
    println!("{}", r3);
} // 老编译器中，r1、r2、r3作用域在这里结束
  // 新编译器中，r3作用域在这里结束
```
### NLL
专门用于找到某个引用在作用域(})结束前就不再被使用的代码位置。

### 悬垂引用
> 指针指向某个值后，这个值被释放掉了，而指针仍然存在，其指向的内存可能不存在任何值或已被其它变量重新使用。也就是野指针

```rust
// rust通过生命周期在编译时期进行判断
fn main() {
    let reference_to_nothing = dangle();
}
fn dangle() -> &String { // dangle 返回一个字符串的引用
    let s = String::from("hello"); // s 是一个新字符串
    &s // 返回字符串 s 的引用
} // 这里 s 离开作用域并被丢弃。其内存被释放。出现野指针
// 解决方案：String 的所有权被转移给外面的调用者。
fn no_dangle() -> String {
    let s = String::from("hello");
    s
}  
```

### 借用规则总结
借用规则如下：
* 同一时刻，你只能拥有要么一个可变引用, 要么任意多个不可变引用
* 引用必须总是有效的