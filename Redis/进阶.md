# 数据类型的选择

## String类型内存消耗
### 实际数据存储
* int 编码方式：当保存 64 位有符号整数时，String 类型会把它保存为一个 8 字节的 Long 类型整数
* 简单动态字符串（Simple Dynamic String，SDS）结构：保存的数据中包含字符时
  * buf：字节数组，保存实际数据。为了表示字节数组的结束，Redis 会自动在数组最后加一个“\0”，这就会额外占用 1 个字节的开销。
  * len：占 4 个字节，表示 buf 的已用长度。
  * alloc：也占个 4 字节，表示 buf 的实际分配长度，一般大于 len。

### RedisObject结构体
记录元数据，同时指向实际数据。RedisObject 包含了 8 字节的元数据和一个 8 字节指针。

![string存储结构](assets/string存储.png)

### 全局哈希表保存所有键值对
哈希表的每一项是一个 dictEntry 的结构体，用来指向一个键值对。dictEntry 结构中有三个 8 字节的指针，分别指向 key、value 以及下一个 dictEntry，三个指针共 24 字节。

Redis 使用的内存分配库 jemalloc。在分配内存时，会根据我们申请的字节数 N，找一个比 N 大，但是最接近 N 的 2 的幂次数作为分配的空间，这样可以减少频繁分配的次数。举个例子。如果你申请 6 字节空间，jemalloc 实际会分配 8 字节空间。

## 数据结构节省内存

### 压缩列表
压缩列表（ziplist），是一种非常节省内存的结构。压缩列表数据结构
* prev_len，表示前一个 entry 的长度。prev_len 有两种取值情况，1 字节或 5 字节。：
  * 取值 1 字节时，表示上一个 entry 的长度小于 254 字节。压缩列表中 zlend 的取值默认是 255，因此，默认用 255 表示整个压缩列表的结束其他表示长度的地方就不能再用 255 这个值了。所以，当上一个 entry 长度小于 254 字节时，prev_len 取值为 1 字节
  * 否则，就取值为 5 字节。
* len：表示自身长度，4 字节；
* encoding：表示编码方式，1 字节；
* content：保存实际数据。

entry 会挨个儿放置在内存中，不需要再用额外的指针进行连接，这样就可以节省指针所占用的空间。

Redis 基于压缩列表实现了 List、Hash 和 Sorted Set 这样的集合类型，这样做的最大好处就是节省了 dictEntry 的开销。当你用 String 类型时，一个键值对就有一个 dictEntry，要用 32 字节空间。但采用集合类型时，一个 key 就对应一个集合的数据，能保存的数据多了很多，但也只用了一个 dictEntry，这样就节省了内存。

### 集合类型
Redis Hash 类型的两种底层实现结构，分别是压缩列表和哈希表。
两个配置项：
* hash-max-ziplist-entries：表示用压缩列表保存时哈希集合中的最大元素个数。
* hash-max-ziplist-value：表示用压缩列表保存时哈希集合中单个元素的最大长度。

一旦从压缩列表转为了哈希表，Hash 类型就会一直用哈希表进行保存，而不会再转回压缩列表了。在节省内存空间方面，哈希表就没有压缩列表那么高效了。