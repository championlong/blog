# 并发

## sync.Map使用

键的实际类型不能是函数类型、字典类型和切片类型。
### 尽量避免使用锁
sync.Map类型在内部使用了大量的原子操作来存取键和值，并使用了两个原生的map作为存储介质。

### 结构
* 其中一个原生map被存在了sync.Map的read字段中，该字段是`sync/atomic.Value`类型的。只读字典不会增减其中的键，但却允许变更其中的键所对应的值。只读字典在存储键值对的时候，先把值转换为了`unsafe.Pointer`类型的值，然后再把后者封装，并储存在其中的原生字典中，这样在变更某个键所对应的值的时候，就也可以使用原子操作了。
* 另一个原生字典由它的dirty字段代表。脏字典存储键值对的方式与read字段中的原生字典一样，同样是把值先做转换和封装后再进行储存的。

脏字典和只读字典如果都存有同一个键值对，两个字典在存储键和值的时候都只会存入它们的某个指针，而不是基本值。

### 相关操作流程
* 在查找指定的键所对应的值的时候，总会先去只读字典中寻找，并不需要锁定互斥锁。只有当确定“只读字典中没有，但脏字典中可能会有这个键”的时候，它才会在锁的保护下去访问脏字典。
* sync.Map在存储键值对的时候，只要只读字典中已存有这个键，并且该键值对未被标记为“已删除”，就会把新值存到里面并直接返回，这种情况下也不需要用到锁。否则，它才会在锁的保护下把键值对存储到脏字典中。这个时候，该键值对的“已删除”标记会被抹去。
* 当一个键值对应该被删除，但却仍然存在于只读字典中的时候，才会被用标记为“已删除”的方式进行逻辑删除，而不会直接被物理删除。删除键值对，sync.Map会先去检查只读字典中是否有对应的键。如果没有，脏字典中可能有，那么它就会在锁的保护下，试图从脏字典中删掉该键值对。最后，sync.Map会把该键值对中指向值的那个指针置为nil

### 只读字典和脏字典交换
在脏字典中查找键值对次数足够多的时候，sync.Map会把脏字典直接作为只读字典，保存在它的read字段中，然后把代表脏字典的dirty字段的值置为nil。在这之后，一旦再有新的键值对存入，它就会依据只读字典去重建脏字典。这个时候，它会把只读字典中已被逻辑删除的键值对过滤掉。

### 性能场景
在读操作有很多但写操作却很少的情况下，并发安全字典的性能往往会更好。在几个写操作当中，新增键值对的操作对并发安全字典的性能影响是最大的，其次是删除操作，最后才是修改操作。