# 同步
竞态条件：一旦数据被多个线程共享，那么就很可能会产生争用和冲突的情况

共享数据的一致性：多个线程对共享数据的操作总是可以达到它们各自预期的效果。

同步步的用途有两个，一个是避免多个线程在同一时刻操作同一个数据块，另一个是协调多个线程，以避免它们在同一时刻执行同一个代码块。

结构体类型的值在被真正使用之后，就不应该再被复制了。

# 互斥量 Mutex
一个互斥锁可以保证，在同一时刻只有一个goroutine处于该临界区之内。
```go
var mu sync.Mutex
mu.Lock()
....
mu.Unlock()
```
Go语言运行时系统自行抛出的`panic`都属于致命错误，都是无法被恢复的，调用`recover`函数对它们起不到任何作用。也就是说，一旦产生死锁，程序必然崩溃。使用互斥锁的注意事项:
1. 不要重复锁定互斥锁；
2. 不要忘记解锁互斥锁，必要时使用defer语句；
3. 不要对尚未锁定或者已解锁的互斥锁解锁；
4. 不要在多个函数之间直接传递互斥锁
5. 该类型是一个结构体类型，属于值类型中的一种。把它传给一个函数、将它从函数中返回、把它赋给其他变量、让它进入某个通道都会导致它的副本的产生。副本之间都是完全独立的，是不同的互斥锁。

# 读写锁
读写锁由`sync.RWMutex`类型的值代表，是把对共享资源的“读操作”和“写操作”区别对待。`sync.RWMutex`类型中的`Lock`方法和`Unlock`方法分别用于对写锁进行锁定和解锁，而它的`RLock`方法和`RUnlock`方法则分别用于对读锁进行锁定和解锁。
```go
var rwMu sync.RWMutex
// 读
rwMu.RLock() 
rwMu.RUnlock()

// 写
rwMu.Lock()
rwMu.Unlock()
```
同一个读写锁来说有如下规则:
1. 在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的goroutine。
2. 在写锁已被锁定的情况下试图锁定读锁，也会阻塞当前的goroutine。
3. 在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的goroutine。
4. 在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的goroutine。

读写锁对写操作之间的互斥，其实是通过它内含的一个互斥锁实现的，Go语言的读写锁是互斥锁的一种扩展。

# 条件变量 sync.Cond
条件变量并不是被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的。当共享资源的状态发生变化时，它可以被用来通知被互斥锁阻塞的线程。

条件变量的通知具有即时性。也就是说，如果发送通知的时候没有goroutine为此等待，那么该通知就会被直接丢弃。在这之后才开始等待的goroutine只可能被后面的通知唤醒。

条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁(也可以是读写锁)的。条件变量提供的方法有三个：
* 等待通知（wait）
* 单发通知（signal）
* 广播通知（broadcast）。

```go
var lock sync.RWMutex
sendCond := sync.NewCond(&lock) // 发送，对共享资源的写操作。
recvCond := sync.NewCond(lock.RLocker()) // 获取，对共享资源的读操作
// 发送
lock.Lock()
for mailbox == 1 {
    sendCond.Wait()
}
mailbox = 1
lock.Unlock()
recvCond.Signal()
```
sendCond.Wait()做了四件事：
1. 把调用它的goroutine（也就是当前的goroutine）加入到当前条件变量的通知队列中。
2. 解锁当前的条件变量基于的那个互斥锁。
3. 让当前的goroutine处于等待状态，等到通知到来时再决定是否唤醒它。此时，这个goroutine就会阻塞在调用这个Wait方法的那行代码上。
4. 如果通知到来并且决定唤醒这个goroutine，那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁。自此之后，当前的goroutine就会继续执行后面的代码了。

# 原子操作
调度器总是会频繁地换上或换下这些goroutine。互斥锁虽然可以保证临界区中代码的串行执行，但却不能保证这些代码执行的原子性。原子操作在进行的过程中是不允许中断的。

正是因为原子操作不能被中断，所以它需要足够简单，并且要求快速。

## 原子操作函数 sync/atomic
sync/atomic包中的函数可以做的原子操作有：
* 加法（add）
* 比较并交换（compare and swap，简称CAS）
* 加载（load）
* 存储（store）
* 交换（swap）。

支持的数据类型：
int32、int64、uint32、uint64、uintptr，以及unsafe包中的Pointer（未提供进行原子加法），Value（用了存储任意类型）。

## sync/atomic.Value
相当于一个容器，可以被用来“原子地”存储和加载任意的值。有两个指针方法：`Store`和`Load`。

注意事项：
1. 第一条规则，不能用原子值存储nil。否则就会引发一个panic。
2. 我们向原子值存储的第一个值，决定了它今后能且只能存储哪一个类型的值。
3. 建议：不要对外暴露原子变量、不要传递原子值及其指针值、尽量不要在原子值中存储引用类型的值

# sync.WaitGroup
WaitGroup类型拥有三个指针方法：`Add`(增加，或者减少这个计数器的值)、`Done`(对其所属值中计数器的值进行减一操作)、`Wait`(阻塞当前的goroutine，直到其所属值中的计数器归零)。

引发问题：
* WaitGroup值中计数器的值不能小于0，是因为这样会引发一个panic。
* 如果有两个goroutine分别对它的Add方法的首次调用，与对它的Wait方法的调用是同时发起的，有可能会让这里的Add方法抛出一个panic。
* goroutine因调用此类值的Wait方法被阻塞，同时另一个goroutine调用了该值的Done方法，并使其计数器的值变为了0。又有一个goroutine调用了它的Add方法，并让其计数器的值又从0变为了某个正整数。此时，这里的Wait方法就会立即抛出一个panic。

要杜绝对同一个WaitGroup值的两种操作的并发执行。

# sync.Once
Once类型的Do方法只接受一个参数，这个参数的类型必须是func()，即：无参数声明和结果声明的函数。

只执行“首次被调用时传入的”那个函数，并且之后不会再执行任何参数函数。

## 原理
类型中通过`sync.Mutex`和`done`的类型字段来保整调用次数。
1. Do方法在一开始就会通过调用atomic.LoadUint32函数来获取`done`字段的值，并且一旦发现该值为1，就会直接返回。
2. Do方法会立即锁定其所属值中的那个sync.Mutex类型的字段m。然后，它会在临界区中再次检查done字段的值，并且仅在条件满足时，才会去调用参数函数
3. Do方法在参数函数执行结束后，对done字段的赋值用的是原子操作，并且，这一操作是被挂在defer语句中的。如果没有执行成功也不会再次执行

由于Do方法只会在参数函数执行结束之后把done字段的值变为1，因此，如果参数函数的执行需要很长时间或者根本就不会结束，那么就有可能会导致相关goroutine的同时阻塞。因为其他的goroutine都会被阻塞在锁定该Once值的互斥锁m的那行代码上。

# Context
所有的Context值共同构成了一颗上下文树。这棵树的作用域是全局的，而根Context值就是这棵树的根。它是全局唯一的，并且不提供任何额外的功能。Context类型的实际值大体上分为三种：
* 根Context值
* 可撤销的Context值(一旦当前的Context值被撤销，这里的接收通道就会被立即关闭，会使任何针对它的接收操作立即结束。)
  * 只可手动撤销的Context值
  * 可以定时撤销的Context值
* 含数据的Context值

```go
cxt, cancelFunc := context.WithCancel(context.Background())
for i := 1; i <= total; i++ {
    go addNum(&num, i, func() {
        if atomic.LoadInt32(&num) == int32(total) {
        cancelFunc()
        }
    })
}
<-cxt.Done()
```
一旦撤销函数被调用，撤销信号就会立即被传达给对应的Context值，并由该值的Done方法返回的接收通道表达出来。

在撤销函数被调用之后，对应的Context值会先关闭它内部的接收通道，也就是它的Done方法会返回的那个通道。然后，它会向它的所有子值（或者说子节点）传达撤销信号。这些子值会如法炮制，把撤销信号继续传播下去。最后，这个Context值会断开它与其父值之间的关联。



context包中还包含了四个用于繁衍Context值的函数，即：
* WithCancel: 函数用于产生一个可撤销的parent的子值
* WithDeadline: 可以被用来产生一个会定时撤销的parent的子值
* WithTimeout: 可以被用来产生一个会定时撤销的parent的子值
* WithValue: 产生一个会携带额外数据的parent的子值, 是不可撤销的, 撤销信号在被传播时，若遇到它们则会直接跨过，并试图将信号直接传给它们的子值。
  * Context类型的Value方法就是被用来获取数据的。在我们调用含数据的Context值的Value方法时，它会先判断给定的键，是否与当前值中存储的键相等，如果相等就把该值中存储的值直接返回，否则就到其父值中继续查找。
  * Context接口并没有提供改变数据的方法。因此，在通常情况下，我们只能通过在上下文树中添加含数据的Context值来存储新的数据，或者通过撤销此种值的父值丢弃掉相应的数据。如果你存储在这里的数据可以从外部改变，那么必须自行保证安全。

# sync.Pool
临时对象的意思是：不需要持久使用的某一类值。临时对象池主要被当作针对某种数据的缓存来用。

临时对象池中存储的每一个值都应该是独立的、平等的和可重用的。我们应该既不用关心从池中拿到的是哪一个值，也不用在意这个值是否已经被使用过。

sync.Pool类型只有两个方法：
* Put: Put用于在当前的池中存放临时对象，它接受一个interface{}类型的参数.
* Get: Get方法可能会从当前的池中删除掉任何一个值，然后把这个值作为结果返回。如果此时当前的池中没有任何值，那么这个方法就会使用当前池的New字段创建一个新值，并直接将其返回。New字段代表着创建临时对象的函数。它的类型是没有参数但有唯一结果的函数类型，即：func() interface{}。

## 何时清理数据
sync包在被初始化的时候，会向Go语言运行时系统注册一个函数，这个函数的功能就是清除所有已创建的临时对象池中的值。我们可以把它称为池清理函数。每次即将执行垃圾回收时就都会执行。

sync包中还有一个包级私有的全局变量，代表了当前的程序中使用的所有临时对象池的汇总，它是元素类型为*sync.Pool的切片。我们可以称之为池汇总列表。

池清理函数会遍历池汇总列表。对于其中的每一个临时对象池，它都会先将池中所有的私有临时对象和共享临时对象列表都置为nil，然后再把这个池中的所有本地池列表都销毁掉。最后，池清理函数会把池汇总列表重置为空的切片。这些池中存储的临时对象就全部被清除干净了。

临时对象池以外的代码再无对它们的引用，那么在稍后的垃圾回收过程中，这些临时对象就会被当作垃圾销毁掉，它们占用的内存空间也会被回收以备他用。

## 数据结构实现
在临时对象池的内部，有一个多层的数据结构支撑着对临时对象的存储。它的顶层是本地池列表，在每个本地池中，都包含一个私有的临时对象和一个共享的临时对象列表。

本地池列表：它是一个数组。这个列表的长度，总是与Go语言调度器中的P的数量相同。

本地池列表中的每个本地池都包含了三个字段（或者说组件），它们是
* 存储私有临时对象的字段private
* 代表了共享临时对象列表的字段shared
* 以及一个sync.Mutex类型的嵌入字段。

一个临时对象池的Put方法或Get方法会获取到哪一个本地池，完全取决于调用它的代码所在的goroutine关联的那个P。

* Put方法总会先试图把新的临时对象，存储到对应的本地池的private字段中，以便在后面获取临时对象的时候，可以快速地拿到一个可用的值。当这个private字段已经存有某个值时，该方法才会去访问本地池的shared字段。
* 临时对象池的Get方法，总会先试图从对应的本地池的private字段处获取一个临时对象。只有当这个private字段的值为nil时，它才会去访问本地池的shared字段。
* 一个本地池的shared字段原则上可以被任何goroutine中的代码访问到，不论这个goroutine关联的是哪一个P。这也是我把它叫做共享临时对象列表的原因。由于shared字段是共享的，所以此时必须受到互斥锁的保护。
* 一个本地池的private字段，只可能被与之对应的那个P所关联的goroutine中的代码访问到，所以可以说，它是P级私有的。
* 所有的临时对象池都刚被大清洗的情况下Get方法就会调用可创建临时对象的那个函数。