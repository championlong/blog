# 管道

> 不要让计算通过共享内存来通讯，而应该让它们通过通讯来共享内存。每个通道内部维护着一个互斥锁用来在各种通道操作中防止数据竞争。

一个通道内部维护了三个队列

*   接收数据协程队列。此队列是一个没有长度限制的双向表。此队列中的协程均处于阻塞状态，它们正等待着从此通道接收数据。
*   发送数据协程队列。此队列也是一个没有长度限制的双向链表。此队列中的协程亦均处于阻塞状态，它们正等待着向此通道发送数据。此队列中的每个协程将要发送的值（或者此值的指针，取决于具体编译器实现）和此协程一起存储在此队列中。
*   数据缓冲队列。这是一个循环队列，它的长度为此通道的容量。此队列中存放的值的类型都为此通道的元素类型。 如果此队列中当前存放的值的个数已经达到此通道的容量，则我们说此通道已经处于满槽状态。 如果此队列中当前存放的值的个数为零，则我们说此通道处于空槽状态。对于一个非缓冲通道（容量为零），它总是同时处于满槽状态和空槽状态。

必然条件

*   如果一个通道已经关闭了，则它的发送数据协程队列和接收数据协程队列肯定都为空，但是它的缓冲队列可能不为空。
*   在任何时刻，如果缓冲队列不为空，则接收数据协程队列必为空。
*   在任何时刻，如果缓冲队列未满，则发送数据协程队列必为空。
*   如果一个通道是缓冲的，则在任何时刻，它的发送数据协程队列和接收数据协程队列之一必为空。
*   如果一个通道是非缓冲的，则在任何时刻，一般说来，它的发送数据协程队列和接收数据协程队列之一必为空， 但是有一个例外：一个协程可能在一个select流程控制中同时被推入到此通道的发送数据协程队列和接收数据协程队列中。

## 操作

*   创建channel:
    ` ch := make(chan int)` `ch := make(chan int, 10) `

*   关闭channel:
    `close(ch)`

关闭原则

> 一个常用的使用Go通道的原则是不要在数据接收方或者在有多个发送者的情况下关闭通道。换句话说，我们只应该让一个通道唯一的发送者关闭此通道。

礼貌的关闭channel

```go
type MyChannel struct {
	C    chan T
	once sync.Once
}

func NewMyChannel() *MyChannel {
	return &MyChannel{C: make(chan T)}
}

func (mc *MyChannel) SafeClose() {
	mc.once.Do(func() {
		close(mc.C)
	})
}
```

*   向通道发送值V:
    `ch <- V`

*   从通道中接收值:
    `<-ch // 忽略接收值`
    `v := <-ch // 接收值并赋值给变量 v`
    `v, beforeClosed := <-ch`

> beforeClosed 代表 v 是否是信道关闭前发送的。true 代表是信道关闭前发送的，false 代表信道已经关闭。如果一个信道已经关闭，<-ch 将永远不会发生阻塞，但是我们可以通过第二个返回值 beforeClosed 得知信道已经关闭，作出相应的处理。

*   查询长度和容量
    `len(ch)`
    `cap(ch)`

> 通道元素传递都是复制过程

> 对于官方标准编译器，最大支持的通道的元素类型的尺寸为65535。 但是，一般说来，为了在数据传递过程中避免过大的复制成本，我们不应该使用尺寸很大的通道元素类型。 如果欲传送的值的尺寸较大，应该改用指针类型做为通道的元素类型。

* 单向通道：只能发而不能收
```go
type Notifier interface {
	SendInt(ch chan<- int)
}
intChan1 := make(chan int, 3)
SendInt(intChan1) // 会自动地把双向通道转换为函数所需的单向通道
```
* 单向通道：只能收不能发
```go
type Notifier interface {
	GetIntChan() <-chan int
}
intChan2 := GetIntChan()
```
# select-case

> 所有的非阻塞case操作中将有一个被随机选择执行（而不是按照从上到下的顺序），然后执行此操作对应的case分支代码块。

```go
select {
	case v. ok := <-c: 
        if !ok {
            break
        }
	    return v
	default:
	    return "-" // 如果c的缓冲为空，则执行默认分支。
}
```

实现机理

1.  将所有case操作中涉及到的通道表达式和发送值表达式按照从上到下，从左到右的顺序一一估值。在赋值语句中做为源值的数据接收操作对应的目标值在此时刻不需要被估值。
2.  将所有分支随机排序。default分支总是排在最后。 所有case操作中相关的通道可能会有重复的。
3.  为了防止在下一步中造成（和其它协程互相）死锁，对所有case操作中相关的通道进行排序。排序依据并不重要，官方Go标准编译器使用通道的地址顺序进行排序。排序结果中前N个通道不存在重复的情况。 N为所有case操作中涉及到的不重复的通道的数量。 下面，通道锁顺序是针对此排序结果中的前N个通道来说的，通道锁逆序是指此顺序的逆序。
4.  按照上一步中的生成通道锁顺序获取所有相关的通道的锁。
5.  按照第2步中生成的分支顺序检查相应分支：
    1.  如果这是一个case分支并且相应的通道操作是一个向关闭了的通道发送数据操作，则按照通道锁逆序解锁所有的通道并在当前协程中产生一个恐慌。 跳到第12步。
    2.  如果这是一个case分支并且相应的通道操作是非阻塞的，则按照通道锁逆序解锁所有的通道并执行相应的case分支代码块。 （此相应的通道操作可能会唤醒另一个处于阻塞状态的协程。） 跳到第12步。
    3.  如果这是default分支，则按照通道锁逆序解锁所有的通道并执行此default分支代码块。 跳到第12步。
        （到这里，default分支肯定是不存在的，并且所有的case操作均为阻塞的。）
6.  将当前协程（和对应case分支信息）推入到每个case操作中对应的通道的发送数据协程队列或接收数据协程队列中。当前协程可能会被多次推入到同一个通道的这两个队列中，因为多个case操作中对应的通道可能为同一个。
7.  使当前协程进入阻塞状态并且按照通道锁逆序解锁所有的通道。
8.  ...，当前协程处于阻塞状态，等待其它协程通过通道操作唤醒当前协程，...
9.  当前协程被另一个协程中的一个通道操作唤醒。此唤醒通道操作可能是一个通道关闭操作，也可能是一个数据发送/接收操作。如果它是一个数据发送/接收操作，则（当前正被解释的select-case流程中）肯定有一个相应case操作与之配合传递数据。在此配合过程中，当前协程将从相应case操作相关的通道的接收/发送数据协程队列中弹出。
10. 按照第3步中的生成的通道锁顺序获取所有相关的通道的锁。
11. 将当前协程从各个case操作中对应的通道的发送数据协程队列或接收数据协程队列中（可能以非弹出的方式）移除。
    1.  如果当前协程是被一个通道关闭操作所唤醒，则跳到第5步。
    2.  如果当前协程是被一个数据发送/接收操作所唤醒，则相应的case分支已经在第9步中知晓。 按照通道锁逆序解锁所有的通道并执行此case分支代码块。
12. 完毕。