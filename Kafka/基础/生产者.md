# 生产者

## 分区

### 诞生的原因
分区的作用就是提供负载均衡的能力，为了实现系统的高伸缩性。不同的分区能够被放置到不同节点的机器上，而数据的读写操作也都是针对分区这个粒度而进行的，这样每个节点的机器都能独立地执行各自分区的读写请求处理。并且，我们还可以通过添加新的节点机器来增加整体系统的吞吐量。

除了提供负载均衡这种最核心的功能之外，利用分区也可以实现其他一些业务级别的需求，比如实现业务级别的消息顺序的问题

### 分区策略
分区策略是决定生产者将消息发送到哪个分区的算法。

#### 自定义
编写一个具体的类实现org.apache.kafka.clients.producer.Partitioner。同时设置partitioner.class参数为你自己实现类
#### 轮询策略
Round-robin策略，即顺序分配。比如一个主题下有3个分区，那么第一条消息被发送到分区0，第二条被发送到分区1，第三条被发送到分区2，以此类推。

Kafka Java生产者API默认提供的分区策略。轮询策略有非常优秀的负载均衡表现，它总是能保证消息最大限度地被平均分配到所有分区上，故默认情况下它是最合理的分区策略，也是我们最常用的分区策略之一。

#### 随机策略
随意地将消息放置到任意一个分区上。先计算出该主题总的分区数，然后随机地返回一个小于它的正整数。

本质上看随机策略也是力求将数据均匀地打散到各个分区，但从实际表现来看，它要逊于轮询策略，所以如果追求数据的均匀分布，还是使用轮询策略比较好。

#### 按消息键保序策略
保证同一个Key的所有消息都进入到相同的分区里面，由于每个分区下的消息处理都是有顺序的，故这个策略被称为按消息键保序策略

#### 其他分区策略
* 基于地理位置的分区策略

## 压缩算法
Producer端压缩、Broker端保持、Consumer端解压缩。
### 压缩方式
Kafka的消息层次都分为两层：消息集合（message set）以及消息（message）

版本比较
* V1: CRC放在消息层，对每个消息校验；保存压缩消息的方法是把多条消息进行压缩然后保存到外层消息的消息体字段中
* V2: CRC放在消息集合层；对整个消息集合进行压缩

### 压缩时机
压缩可能发生在两个地方：生产者端和Broker端。

生产者程序中配置compression.type参数即表示启用指定类型的压缩算法。

大部分情况下Broker从Producer端接收到消息后仅仅是原封不动地保存。但如果Broker端指定了和Producer端不同的压缩算法，或者Broker端发生了消息格式转换。此时就会产生预料之外的压缩/解压缩。
### 解压时机
在消费者端，Broker端也会进行解压缩（每个压缩过的消息集合在Broker端写入时都要发生解压缩操作，目的就是为了对消息执行各种验证。）

### 压缩算法
压缩比，原先占100份空间的东西经压缩之后变成了占20份空间，那么压缩比就是5，显然压缩比越高越好

压缩/解压缩吞吐量，比如每秒能压缩或解压缩多少MB的数据。同样地，吞吐量也是越高越好。

* 吞吐量方面：LZ4 > Snappy > zstd和GZIP
* 在压缩比方面：zstd > LZ4 > GZIP > Snappy


